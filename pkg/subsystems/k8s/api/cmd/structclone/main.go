//go:build ignore

package main

import (
	"fmt"
	"go/format"
	"os"
	"reflect"
	"strings"

	nvresourcebetav1 "github.com/NVIDIA/k8s-dra-driver-gpu/api/nvidia.com/resource/v1beta1"
)

func main() {

	// Generate everything required for the nvidia gpuConfig struct
	// This is done so we dont have to rely on their package as
	// a runtime depencency.
	// Why would we not want to use it?
	// Primarily they have a `func init()` that requires a compile time
	// flag to be set to a specific version for their library to work
	// they use it as a featuregate, but it is not feasable to have to
	// set that flag just to be able to use one struct from their code.
	//
	// Hence this generation code has been made, so we get our own struct
	// that we can use to bind the opaque params to.
	generateRecursive(nvresourcebetav1.GpuConfig{}, "nvidia")

}

func generateRecursive(v any, pkgName string) {
	visited := map[string]bool{}
	t := reflect.TypeOf(v)
	generateType(t, pkgName, t.PkgPath(), visited)
}

func generateType(t reflect.Type, pkgName string, targetPkgPrefix string, visited map[string]bool) {
	if t == nil {
		return
	}

	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	if t.Name() == "" {
		return
	}

	fullName := t.PkgPath() + "." + t.Name()
	if visited[fullName] {
		return
	}
	visited[fullName] = true

	isLocal := strings.HasPrefix(t.PkgPath(), targetPkgPrefix)
	if !isLocal && t.PkgPath() != "" {
		return // external type, skip
	}

	switch t.Kind() {
	case reflect.Struct:
		imports := map[string]string{}
		structDef := renderStruct(t, 0, imports, pkgName, targetPkgPrefix, visited)

		var importLines []string
		for alias, path := range imports {
			if strings.HasPrefix(path, targetPkgPrefix) {
				continue
			}
			importLines = append(importLines, fmt.Sprintf("\t%s \"%s\"", alias, path))
		}
		importSection := ""
		if len(importLines) > 0 {
			importSection = "import (\n" + strings.Join(importLines, "\n") + "\n)\n\n"
		}

		code := fmt.Sprintf(`// Code generated by go:generate with kthcloud/go-deploy/pkg/subsystems/k8s/api/cmd/structclone; DO NOT EDIT.

package %s

%s
type %s %s
`, pkgName, importSection, t.Name(), structDef)

		writeFile(pkgName, t.Name(), code)
		fmt.Println("Generated struct:", t.Name())

	default:
		base := resolveUnderlyingType(t, visited, pkgName, targetPkgPrefix)
		code := fmt.Sprintf(`// Code generated by go:generate with kthcloud/go-deploy/pkg/subsystems/k8s/api/cmd/structclone; DO NOT EDIT.

package %s

type %s %s
`, pkgName, t.Name(), base)

		writeFile(pkgName, t.Name(), code)
		fmt.Println("Generated alias:", t.Name())
	}
}

func renderStruct(t reflect.Type, indent int, imports map[string]string, pkgName string, targetPkgPrefix string, visited map[string]bool) string {
	var b strings.Builder
	ind := strings.Repeat("\t", indent)
	b.WriteString("struct {\n")

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		if f.PkgPath != "" {
			continue
		}

		name := f.Name
		fieldType := typeString(f.Type, imports, pkgName, targetPkgPrefix, visited)
		tag := f.Tag.Get("json")
		if tag == "" {
			tag = strings.ToLower(name)
		}
		if strings.Contains(tag, "inline") {
			// if it is inline we embed it
			name = ""
		}

		b.WriteString(fmt.Sprintf("%s\t%s %s `json:\"%s\"`\n", ind+"\t", name, fieldType, tag))
	}

	b.WriteString(ind + "}")
	return b.String()
}

func typeString(t reflect.Type, imports map[string]string, pkgName string, targetPkgPrefix string, visited map[string]bool) string {
	if t == nil {
		return "interface{}"
	}

	switch t.Kind() {
	case reflect.Pointer:
		return "*" + typeString(t.Elem(), imports, pkgName, targetPkgPrefix, visited)
	case reflect.Slice:
		return "[]" + typeString(t.Elem(), imports, pkgName, targetPkgPrefix, visited)
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), typeString(t.Elem(), imports, pkgName, targetPkgPrefix, visited))
	case reflect.Map:
		return fmt.Sprintf("map[%s]%s", typeString(t.Key(), imports, pkgName, targetPkgPrefix, visited), typeString(t.Elem(), imports, pkgName, targetPkgPrefix, visited))
	case reflect.Struct:
		if strings.HasPrefix(t.PkgPath(), targetPkgPrefix) {
			generateType(t, pkgName, targetPkgPrefix, visited)
			return t.Name()
		}

		if t.PkgPath() != "" {
			parts := strings.Split(t.PkgPath(), "/")
			pkgAlias := parts[len(parts)-1]
			imports[pkgAlias] = t.PkgPath()
			return fmt.Sprintf("%s.%s", pkgAlias, t.Name())
		}
		return t.Name()

	default:
		if strings.HasPrefix(t.PkgPath(), targetPkgPrefix) {
			generateType(t, pkgName, targetPkgPrefix, visited)
			return t.Name()
		}

		if t.PkgPath() != "" {
			parts := strings.Split(t.PkgPath(), "/")
			pkgAlias := parts[len(parts)-1]
			imports[pkgAlias] = t.PkgPath()
			return fmt.Sprintf("%s.%s", pkgAlias, t.Name())
		}

		return t.Name()
	}
}

// resolveUnderlyingType returns the real Go type (e.g. "string", "int", etc.)
// for alias-like types (GpuSharingStrategy => string)
func resolveUnderlyingType(t reflect.Type, visited map[string]bool, pkgName string, targetPkgPrefix string) string {
	// Deref pointers
	for t.Kind() == reflect.Pointer {
		t = t.Elem()
	}

	// Try to find base kind
	switch t.Kind() {
	case reflect.Struct:
		return t.Name()
	case reflect.Slice:
		return "[]" + resolveUnderlyingType(t.Elem(), visited, pkgName, targetPkgPrefix)
	case reflect.Map:
		return fmt.Sprintf("map[%s]%s",
			resolveUnderlyingType(t.Key(), visited, pkgName, targetPkgPrefix),
			resolveUnderlyingType(t.Elem(), visited, pkgName, targetPkgPrefix))
	case reflect.String:
		return "string"
	case reflect.Bool:
		return "bool"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "int"
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "uint"
	case reflect.Float32:
		return "float32"
	case reflect.Float64:
		return "float64"
	case reflect.Interface:
		return "interface{}"
	default:
		// Try to generate nested type if local
		if strings.HasPrefix(t.PkgPath(), targetPkgPrefix) {
			generateType(t, pkgName, targetPkgPrefix, visited)
			return t.Name()
		}
		// External alias, import required
		if t.PkgPath() != "" {
			parts := strings.Split(t.PkgPath(), "/")
			pkgAlias := parts[len(parts)-1]
			return fmt.Sprintf("%s.%s", pkgAlias, t.Name())
		}
		return t.Kind().String()
	}
}

func writeFile(pkgName, name, code string) {
	os.MkdirAll(pkgName, 0755)
	outPath := fmt.Sprintf("%s/%s.go", pkgName, strings.ToLower(name))

	// Run gofmt on the generated code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		fmt.Fprintf(os.Stderr, "warning: could not format %s: %v\n", outPath, err)
		formatted = []byte(code)
	}

	if err := os.WriteFile(outPath, formatted, 0644); err != nil {
		panic(err)
	}
}
